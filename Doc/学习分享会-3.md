# 穷举算法及其优化
## 何为穷举

- 顾名思义：穷尽、列举所有的可能
- 一种求解问题的“暴力”方法（brute-force，not violence..）
- “万能”算法

## 两种搜索模式（穷举的方式）
- 深度优先搜索（深搜，DFS）
- 广度优先搜索（宽搜，BFS，洪漫算法）

## 如何使用穷举求解问题
1. 生成所有的可能
    - 邮递员问题（TSP）：城市的全排列
    - 走迷宫：从起点开始的所有走法（简单路径）/每一步走的方向构成的序列
    - 期中考最后一题（去括号使括号序列合法）：括号的组合/每个括号保留或去掉/01序列
2. 对于生成的每一种可能，检验其是否符合要求
    - 若符合要求，做相应的记录/更新
        - 求合法解的数量：计数器+1
        - 求最优解：更新当前最优解

## 怎么用程序实现穷举（DFS）
- 生成所有可能： 从头到尾填一个待定的状态数组
    - 通常使用递归，状态维数较少时可使用（多重）循环
- 递归函数的结构
    - 函数参数：表征当前状态（状态数组、填到第几位）
    - 搜到底了
        - 已经生成了一种可能
        - 检验这种可能，做相应更新
    - 没搜到底
        - 选择当前位填什么
        - 选了一种填法，就继续递归填下一个
    - 代码架构 _（非真实代码，state不一定是数组，不一定是单个变量）_
    ```c++
    void DFS(state, position) {
        if (position > last_position_to_fill) {
            if (is_valid(state))
                update(state);
        } else {
            for each possible choice {
                state[position] = this_choice;
                DFS(state, position + 1);
            }
        }
    }

    ```
    
## 如何优化穷举
- 穷举的时间复杂度分析
    - 穷举复杂度 = 状态数 \* 合法性检查的复杂度
    - 优化的切入点：减少穷举的状态数
- 减少状态数——剪枝（主要针对DFS）
    - “剪枝”的理解：去掉搜索树上无效的子树
    - 可行性剪枝：将搜到底才做的**合法性检验**提前到搜索的每一步
        - 若当前位的这种填法直接使状态不可能合法，则不向下递归
    - 最优性剪枝：将搜到底才做的**判断是否最优解**提前到搜索的每一步
        - 若当前位的这种填法使状态不可能比当前最优解更优，则不向下递归
    - 冗余性剪枝：本质相同的状态只搜一个
    - 调整搜索顺序：使较优解更快出现，最优性剪枝发挥更大作用
    - 按随机/贪心生成一个解，提高搜索的初始最优解下界，配合最优性剪枝
    - ……
- 剪枝优化对时间复杂度的影响
    - 一般不会降低复杂度
    - 实际上可能大幅降低运算量

## 小结
- 穷举是指穷尽、列举问题**所有的可能**（状态、解）。
- 穷举是求解大部分状态数有限的问题的**通用方法**。
- 搜索的两种模式是：深度优先搜索（DFS）、广度优先搜索（BFS）
- 穷举的时间复杂度 = 状态数 \* 合法性检查的复杂度，当**状态数较多**时穷举会非常**低效**。
- 搜索**剪枝**是优化DFS的一类方法，以**减少搜索状态数**为目标。具体有可行性剪枝、最优性剪枝、冗余性剪枝等，需根据题目特性选择。
- 良好的剪枝能大幅降低运算量，但一般**不能降低时间复杂度**。若剪枝优化仍不能满足效率需要，就必须针对问题选择更适合、更高效的算法。


### 附
- 填数独
```c++

int a[10][10];   // initialize a[i][j] = -1 if it is not given
void DFS(int x, int y) {
    if (x == 10) {
        if (is_valid(a)) {
            print(a);
        }
    } else {
        int next_x = (y < 9) ? x : x + 1;
        int next_y = (y < 9) ? y + 1 : 1;
        if (a[x][y] > 0) {  // the number is given
            DFS(next_x, next_y);
        } else {
            for (int choice = 1; choice <= 9; choice++) {
                a[x][y] = choice;
                if (!check(a))      // invalid
                    continue;
                DFS(next_x, next_y);
            }
            a[x][y] = -1;  // restore a[x][y], otherwise next time DFS(x,y) will recognize it as a given number
        }
    }
}

```
